from fastapi import APIRouter, HTTPException
from typing import List, Optional
from models import BlogPost, BlogPostCreate
from server import db

router = APIRouter(prefix="/api/blog", tags=["blog"])

@router.get("", response_model=List[BlogPost])
async def get_blog_posts(category: Optional[str] = None, search: Optional[str] = None):
    query = {}
    
    if category and category != "All":
        query["category"] = category
    
    if search:
        query["$or"] = [
            {"title": {"$regex": search, "$options": "i"}},
            {"excerpt": {"$regex": search, "$options": "i"}}
        ]
    
    posts = await db.blog_posts.find(query).to_list(1000)
    return [BlogPost(**post) for post in posts]

@router.get("/{post_id}", response_model=BlogPost)
async def get_blog_post(post_id: str):
    post = await db.blog_posts.find_one({"id": post_id})
    if not post:
        raise HTTPException(status_code=404, detail="Blog post not found")
    return BlogPost(**post)

@router.post("", response_model=BlogPost)
async def create_blog_post(post: BlogPostCreate):
    post_obj = BlogPost(**post.dict())
    await db.blog_posts.insert_one(post_obj.dict())
    return post_obj

@router.put("/{post_id}", response_model=BlogPost)
async def update_blog_post(post_id: str, post: BlogPostCreate):
    existing = await db.blog_posts.find_one({"id": post_id})
    if not existing:
        raise HTTPException(status_code=404, detail="Blog post not found")
    
    updated_post = BlogPost(id=post_id, **post.dict())
    await db.blog_posts.replace_one({"id": post_id}, updated_post.dict())
    return updated_post

@router.delete("/{post_id}")
async def delete_blog_post(post_id: str):
    result = await db.blog_posts.delete_one({"id": post_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Blog post not found")
    return {"message": "Blog post deleted successfully"}